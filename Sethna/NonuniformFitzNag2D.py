# 
# See the exercise "CardiacDynamics.pdf" from CardiacDynamics.html 
# in  http://www.physics.cornell.edu/sethna/StatMech/ComputerExercises/
#
# Fully functional two-dimensional simulation of the Fitzhugh-Nagumo
# model for cardiac dynamics: allows for spatial inhomogeneity in the
# tissue parameters.

import scipy, scipy.optimize
from DynamicLattice import *

DISPLAYINTERVAL=10

def del2_5(x, dx):
    """del2_5(x, dx) returns a finite-difference approximation of the
    laplacian of the array x, with lattice spacing dx, using the five-point
    stencil:

    0   1   0
    1  -4   1
    0   1   0

    Compute the laplacian by shifting the array x appropriately (up, down,
    left, and right) to implement the stencil.  The resulting array returned
    should represent the laplacian of the array x on all of the interior
    points of the array x[1:-1, 1:-1]
    """
    nx, ny = x.shape
    del2 = scipy.zeros((nx, ny), float)
    del2[1:-1, 1:-1] = (x[1:-1,2:] + x[1:-1,:-2] + \
                        x[2:,1:-1] + x[:-2,1:-1] - 4.*x[1:-1,1:-1])/(dx*dx)
    return del2     

def del2_9(x, dx):
    """del2_9(x, dx) returns a finite-difference approximation of the
    laplacian of the array x, with lattice spacing dx, using the nine-point
    stencil:

    1/6   2/3   1/6
    2/3 -10/3   2/3
    1/6   2/3   1/6


    Compute the laplacian by shifting the array x appropriately (up, down,
    left, and right) to implement the stencil.  The resulting array returned
    should represent the laplacian of the array x on all of the interior
    points of the array x[1:-1, 1:-1]
    """
    nx, ny = x.shape
    del2 = scipy.zeros((nx, ny), float)
    del2[1:-1, 1:-1] = ((2./3.)*x[1:-1,2:] + (2./3.)*x[1:-1,:-2] + \
                       (2./3.)*x[2:,1:-1] + (2./3.)*x[:-2,1:-1] - \
                       (10./3.)*x[1:-1,1:-1] + \
                       (1./6.)*x[2:,2:] + (1./6.)*x[2:,:-2] + \
                       (1./6.)*x[:-2,2:] + (1./6.)*x[:-2,:-2])/(dx*dx)
    return del2     

del2 = del2_9


def FindFixedPoint(gamma, beta):
    f = lambda v, gamma, beta: (v-(v**3)/3.)-((1./gamma)*(v+beta))
    vstar = scipy.optimize.brentq(f, -2., 2., args=(gamma, beta))
    wstar = ((1./gamma)*(vstar+beta))
    return vstar, wstar


def copyghost(x):
    Nx, Ny = x.shape
    x[0,:] = x[1,:]
    x[:,0] = x[:,1]
    x[Nx-1,:] = x[Nx-2,:]
    x[:,Ny-1] = x[:,Ny-2]

class FitzNag2D:
    """FitzNag2D is a class to support the simulation of the FitzHugh-Nagumo
    equations on a 2D square grid."""

    def __init__(self, N=100, dx=1.0,
                 eps=0.2, gamma=0.8, beta=0.7):
        """Initialize a FitzNag2D2D class, consisting of NxN points on a
        square grid with lattice spacing dx, and model parameters eps,
        gamma and beta; the FitzHugh-Nagumo equations are:

        dv_dt = laplacian(v) + (1./eps) * (v - (1./3.)*v**3 - w)
        dw_dt = eps*(v - gamma*w + beta)

        The __init__ method will need to store the values of the
        specified parameters, and create the fields v and w (as scipy
        arrays of the appropriate size).  v and w should be initialized
        uniformly to their values at the fixed point (resting state),
        vstar and wstar, except for the initialization of a pulse of
        height XX within a square of size 10 at the center of the
        simulation grid.

        The __init__ method should also set a member variable, e.g.,
        self.pulseheight, that will indicate the height of the pulse
        generated by interactive mouse events.

        Animated displays will be taken care of by the DynamicLattice
        class which has been imported.  The FitzNag2D class should
        initialize an instance of DynamicLattice within the __init__
        method:

        self.DL = DynamicLattice((N, N), zmin=-2.0, zmax=2.0)

        This particular instance will animate dynamics on an NxN grid,
        creating grayscale images of a specified field based on the field
        value in the interval (zmin=-2.0, zmax=2.0).
        """

        self.DL = DynamicLattice((N, N), zmin=-2.0, zmax=2.0)
        self.N = N
        self.dx = dx
        self.L = N*dx
        self.D = scipy.ones((N,N), float)
        self.eps = eps * scipy.ones((N,N), float)
        self.gamma = gamma * scipy.ones((N,N), float)
        self.beta = beta * scipy.ones((N,N), float)
        self.pulseheight = 3.0
        vstar, wstar = FindFixedPoint(gamma, beta)
        self.v = vstar*scipy.ones((N, N), float)
        self.w = wstar*scipy.ones((N, N), float)
        self.beta[(N/2-5):(N/2+5), (N/2-5):(N/2+5)] = 0.4
        self.t = 0.

    def rhs(self):
        """self.rhs() sets the instantaneous value of the right-hand-side of
        the FitzHugh-Nagumo equations, by creating two scipy arrays
        self.dv_dt and self.dw_dt, which describe the time evolution of the
        v and w fields, respectively.  self.rhs() will be called by
        the step() method as part of the Euler time-stepping scheme."""
        copyghost(self.v)
        self.dv_dt = self.D*del2(self.v, self.dx) + \
                     (1./self.eps) * (self.v - (1./3.)*self.v**3 - self.w)
        self.dw_dt = self.eps*(self.v - self.gamma*self.w + self.beta)
        
    def step(self, dt):
        """self.step(dt) increments the fields v and w in accordance with
        an Euler time step of size dt, by calling self.rhs() to get the
        current values of the fields self.dv_dt and self.dw_dt."""
        self.rhs()
        self.v += dt * self.dv_dt
        self.w += dt * self.dw_dt

    def run(self, T, dt):
        """self.run(T, dt) integrates the FitzHugh-Nagumo equations for
        a time interval T, by taking steps of size dt.   self.run() should
        also increment an overall time counter by dt.

        Every DISPLAYINTERVAL steps (e.g., 10), interaction with the
        self.DL object should be undertaken, to update the display of
        the v field, and to determine if a pulse box has been selected
        with the mouse.  The display can be updated with the
        self.DL.display() method, which takes an array to be displayed
        as an argument (e.g., self.v).  An additional nicety is to set
        the title of the self.DL window with the current simulation
        time, using the self.DL.setTitle() method.

        The self.DL object supports the query IsBoxSelected(), to ascertain
        whether a region (box) of the grid has been selected with the mouse.
        If a box has been selected, the self.DL.GetMouseBox() can be
        called to unpack a set of grid points (x0, y0, x1, y1) delineating
        the selected box.  The v field within the selected box should be
        set to the pre-selected pulseheight.
        """

        count=0
        t0 = self.t
        while self.t < t0 + T:
            if count%DISPLAYINTERVAL==0:
                if self.DL.IsBoxSelected():
                    x0, y0, x1, y1 = self.DL.GetMouseBox()
                    self.v[x0:x1, y0:y1] = self.pulseheight
                self.DL.setTitle('t = %f' % self.t)
                self.DL.display(self.v)
            self.step(dt)
            self.t += dt
            count +=1

def test():
    f = FitzNag2D(N=100, dx=1.)
    f.run(200., 0.1)
    return f

if __name__ == '__main__':
    f = test()
    

